class_name MDLReader extends RefCounted

enum MDLFlag {
	AUTOGENERATED_HITBOX 									= 0x0001,
	USES_ENV_CUBEMAP 										= 0x0002,
	FORCE_OPAQUE 											= 0x0004,
	TRANSLUCENT_TWOPASS 									= 0x0008,
	STATIC_PROP 											= 0x0010,
	USES_FB_TEXTURE 										= 0x0020,
	HAS_SHADOWLOD 											= 0x0040,
	USES_BUMPMAPPING 										= 0x0080,
	USE_SHADOWLOD_MATERIALS 								= 0x0100,
	OBSOLETE 												= 0x0200,
	UNUSED 													= 0x0400,
	NO_FORCED_FADE 											= 0x0800,
	FORCE_PHONEME_CROSSFADE 								= 0x1000,
	CONSTANT_DIRECTIONAL_LIGHT_DOT 							= 0x2000,
	FLEXES_CONVERTED 										= 0x4000,
	BUILT_IN_PREVIEW_MODE 									= 0x8000,
	AMBIENT_BOOST 											= 0x10000,
	DO_NOT_CAST_SHADOWS 									= 0x20000,
	CAST_TEXTURE_SHADOWS 									= 0x40000,
	NA1 													= 0x80000,
	NA2 													= 0x100000,
	VERT_ANIM_FIXED_POINT_SCALE 							= 0x200000,
}

class MDLHeader:
	static var scheme: 
		get: return {
		id 													= [ByteReader.Type.STRING, 4],
		version 											= ByteReader.Type.INT,
		checksum 											= ByteReader.Type.INT,
		name 												= [ByteReader.Type.STRING, 64],
		length 												= ByteReader.Type.INT,
		eye_position 										= ByteReader.Type.VECTOR3,
		illum_position 										= ByteReader.Type.VECTOR3,
		hull_min 											= ByteReader.Type.VECTOR3,
		hull_max 											= ByteReader.Type.VECTOR3,
		view_bb_min 										= ByteReader.Type.VECTOR3,
		view_bb_max 										= ByteReader.Type.VECTOR3,
		flags 												= ByteReader.Type.INT,
		bone_count  										= ByteReader.Type.INT,
		bone_offset 										= ByteReader.Type.INT,
		bone_controller_count 								= ByteReader.Type.INT,
		bone_controller_offset 								= ByteReader.Type.INT,
		hitbox_count 										= ByteReader.Type.INT,
		hitbox_offset 										= ByteReader.Type.INT,
		anim_count  										= ByteReader.Type.INT,
		anim_offset 										= ByteReader.Type.INT,
		local_anim_count 									= ByteReader.Type.INT,
		local_anim_offset 									= ByteReader.Type.INT,
		activity_list_version 								= ByteReader.Type.INT,
		events_indexed 										= ByteReader.Type.INT,
		texture_count 										= ByteReader.Type.INT,
		texture_offset 										= ByteReader.Type.INT,
		texturedir_count 									= ByteReader.Type.INT,
		texturedir_offset 									= ByteReader.Type.INT,
		skin_count											= ByteReader.Type.INT,
		skinfamily_count  									= ByteReader.Type.INT,
		skin_offset 										= ByteReader.Type.INT,
		bodypart_count 										= ByteReader.Type.INT,
		bodypart_offset 									= ByteReader.Type.INT,
		attachment_count  									= ByteReader.Type.INT,
		attachment_offset 									= ByteReader.Type.INT,
		local_node_count 									= ByteReader.Type.INT,
		local_node_index 									= ByteReader.Type.INT,
		local_node_name_index 								= ByteReader.Type.INT,
		flex_desc_count 									= ByteReader.Type.INT,
		flex_desc_index 									= ByteReader.Type.INT,
		flex_controller_count 								= ByteReader.Type.INT,
		flex_controller_index 								= ByteReader.Type.INT,
		ikchain_count 										= ByteReader.Type.INT,
		ikchain_index 										= ByteReader.Type.INT,
		mouth_count 										= ByteReader.Type.INT,
		mouth_offset 										= ByteReader.Type.INT,
		local_pose_param_count 								= ByteReader.Type.INT,
		local_pose_param_index 								= ByteReader.Type.INT,
		surface_prop_index 									= ByteReader.Type.INT,
		key_value_index 									= ByteReader.Type.INT,
		key_value_size 										= ByteReader.Type.INT,
		ik_lock_count 										= ByteReader.Type.INT,
		ik_lock_index 										= ByteReader.Type.INT,
		mass 												= ByteReader.Type.FLOAT,
		contents 											= ByteReader.Type.INT,
		include_model_count 								= ByteReader.Type.INT,
		include_model_index 								= ByteReader.Type.INT,
		virtual_model 										= ByteReader.Type.INT,
		anim_block_name_index 								= ByteReader.Type.INT,
		anim_block_count 									= ByteReader.Type.INT,
		anim_block_index 									= ByteReader.Type.INT,
		anim_block_model_index 								= ByteReader.Type.INT,
		bone_table_name_index 								= ByteReader.Type.INT,
		vertex_base 										= ByteReader.Type.INT,
		offset_base 										= ByteReader.Type.INT,
		directional_light_dot 								= ByteReader.Type.BYTE,
		root_lod 											= ByteReader.Type.BYTE,
		allowed_root_lod 									= ByteReader.Type.BYTE,
		unused0 											= ByteReader.Type.BYTE,
		unused1 											= ByteReader.Type.INT,
		flex_controller_ui_count 							= ByteReader.Type.INT,
		flex_controller_ui_index 							= ByteReader.Type.INT,
		vert_anim_fixed_point_scale 						= ByteReader.Type.FLOAT,
		unused2 											= ByteReader.Type.INT,
		studio_hdr2_index 									= ByteReader.Type.INT,
		unused3 											= ByteReader.Type.INT,
	};

	var id: String;
	var version: int;
	var checksum: int;
	var name: String;
	var length: int;
	var eye_position: Vector3;
	var illum_position: Vector3;
	var hull_min: Vector3;
	var hull_max: Vector3;
	var view_bb_min: Vector3;
	var view_bb_max: Vector3;
	var flags: MDLFlag;
	var bone_count: int;
	var bone_offset: int;
	var bone_controller_count: int;
	var bone_controller_offset: int;
	var hitbox_count: int;
	var hitbox_offset: int;
	var anim_count: int;
	var anim_offset: int;
	var local_anim_count: int;
	var local_anim_offset: int;
	var activity_list_version: int;
	var events_indexed: int;
	var texture_count: int;
	var texture_offset: int;
	var texturedir_count: int;
	var texturedir_offset: int;
	var skin_count: int;
	var skinfamily_count: int;
	var skin_offset: int;
	var bodypart_count: int;
	var bodypart_offset: int;
	var attachment_count: int;
	var attachment_offset: int;
	var local_node_count: int;
	var local_node_index: int;
	var local_node_name_index: int;
	var flex_desc_count: int;
	var flex_desc_index: int;
	var flex_controller_count: int;
	var flex_controller_index: int;
	var ikchain_count: int;
	var ikchain_index: int;
	var mouth_count: int;
	var mouth_offset: int;
	var local_pose_param_count: int;
	var local_pose_param_index: int;
	var surface_prop_index: int;
	var key_value_index: int;
	var key_value_size: int;
	var ik_lock_count: int;
	var ik_lock_index: int;
	var mass: float;
	var contents: int;
	var include_model_count: int;
	var include_model_index: int;
	var virtual_model: int;
	var anim_block_name_index: int;
	var anim_block_count: int;
	var anim_block_index: int;
	var anim_block_model_index: int;
	var bone_table_name_index: int;
	var vertex_base: int;
	var offset_base: int;
	var directional_light_dot: int; # byte
	var root_lod: int; # byte
	var allowed_root_lod: int; # byte
	var unused0: int; # byte
	var unused1: int;
	var flex_controller_ui_count: int;
	var flex_controller_ui_index: int;
	var vert_anim_fixed_point_scale: float;
	var unused2: int;
	var studio_hdr2_index: int;
	var unused3: int;

	var address: int = 0;

	func _to_string():
		return ByteReader.get_structure_string("MDLHeader", self);

class MDLTexture:
	static var scheme: 
		get: return {
		name_offset 									= ByteReader.Type.INT,
		flags 											= ByteReader.Type.INT,
		used 											= ByteReader.Type.INT,
		unused 											= ByteReader.Type.INT,
		material 										= ByteReader.Type.INT,
		client_material 								= ByteReader.Type.INT,
		unused2 										= [ByteReader.Type.INT, 10],
	};

	var name_offset: int;
	var name: String;
	var flags: int;
	var used: int;
	var unused: int;
	var material: int;
	var client_material: int;
	var unused2: Array[int];

	var address: int = 0;

	func _to_string():
		return "MDLTexture: {name: %s, flags: %d, used: %d, unused: %d, material: %d, client_material: %d, unused2: %s}" % [name, flags, used, unused, material, client_material, unused2];

class MDLBone:
	static var scheme:
		get: return {
		name_offset 									= ByteReader.Type.INT,
		parent 											= ByteReader.Type.INT,
		bonecontrollers 								= [ByteReader.Type.INT, 6],
		pos 											= ByteReader.Type.VECTOR3,
		quat 											= ByteReader.Type.QUATERNION,
		rot 											= ByteReader.Type.EULER_VECTOR,
		pos_scale 										= ByteReader.Type.VECTOR3,
		rot_scale 										= ByteReader.Type.VECTOR3,
		pos_to_bone 									= ByteReader.Type.MAT3X4,
		q_alignment 									= ByteReader.Type.QUATERNION,
		flags 											= ByteReader.Type.INT,
		proc_type 										= ByteReader.Type.INT,
		proc_index 										= ByteReader.Type.INT,
		physics_bone 									= ByteReader.Type.INT,
		surface_prop_index 								= ByteReader.Type.INT,
		contents 										= ByteReader.Type.INT,
		unused 											= [ByteReader.Type.BYTE, 32],
	}

	var id: int;
	var name_offset: int;
	var name: String;
	var parent: int;
	var bonecontrollers: Array[int];
	var pos: Vector3;
	var quat: Quaternion;
	var rot: Vector3;
	var pos_scale: Vector3;
	var rot_scale: Vector3;
	var pos_to_bone: Transform3D;
	var q_alignment: Quaternion;
	var flags: int;
	var proc_type: int;
	var proc_index: int;
	var physics_bone: int;
	var surface_prop_index: int;
	var contents: int;
	var unused: Array[int];
	var surface_prop: String;

	var address: int = 0;

	## Via \n for better readability
	func _to_string():
		return ("MDLBone: {\n\tname: %s, parent: %d, bonecontrollers: %s, pos: %s, quat: %s, rot: %s, pos_scale: %s, rot_scale: %s, pos_to_bone: %s, q_alignment: %s, flags: %d, proc_type: %d, proc_index: %d, physics_bone: %d, surface_prop_index: %d, contents: %d, unused: %s}".replace("%s, ", "%s,\n\t").replace("%d, ", "%d,\n\t") % [name, parent, bonecontrollers, pos, quat, rot, pos_scale, rot_scale, pos_to_bone, q_alignment, flags, proc_type, proc_index, physics_bone, surface_prop_index, contents, unused]);

class MDLBoneController:
	static var scheme:
		get: return {
		bone 											= ByteReader.Type.INT,
		type 											= ByteReader.Type.INT,
		start 											= ByteReader.Type.FLOAT,
		end 											= ByteReader.Type.FLOAT,
		rest 											= ByteReader.Type.INT,
		input_field 									= ByteReader.Type.INT,
		unused 											= [ByteReader.Type.INT, 8],
	}

	var bone: int;
	var type: int;
	var start: float;
	var end: float;
	var rest: int;
	var input_field: int;

	func _to_string():
		return "MDLBoneController: {bone: %d, type: %d, start: %f, end: %f, rest: %d, input_field: %d}" % [bone, type, start, end, rest, input_field];

class MDLMovement:
	static var scheme:
		get: return {
		endframe 										= ByteReader.Type.INT,
		motionflags 									= ByteReader.Type.INT,
		v0 												= ByteReader.Type.FLOAT,
		v1 												= ByteReader.Type.FLOAT,
		angle 											= ByteReader.Type.FLOAT,
		vector 											= ByteReader.Type.VECTOR3,
		position 										= ByteReader.Type.VECTOR3,
	}

	var endframe: int;
	var motionflags: int;
	var v0: float;
	var v1: float;
	var angle: float;
	var vector: Vector3;
	var position: Vector3;

	var address: int = 0;

class MDLIKRule:
	static var scheme:
		get: return {
		index 											= ByteReader.Type.INT,
		type 											= ByteReader.Type.INT,
		chain 											= ByteReader.Type.INT,
		bone 											= ByteReader.Type.INT,
		slot 											= ByteReader.Type.INT,
		height 											= ByteReader.Type.FLOAT,
		radius 											= ByteReader.Type.FLOAT,
		floor 											= ByteReader.Type.FLOAT,
		pos 											= ByteReader.Type.VECTOR3,
		q 												= ByteReader.Type.QUATERNION,
		compressedikerrorindex 							= ByteReader.Type.INT,
		unused2 										= ByteReader.Type.INT,
		i_start 										= ByteReader.Type.INT,
		ikerrorindex 									= ByteReader.Type.INT,
		start 											= ByteReader.Type.FLOAT,
		peak 											= ByteReader.Type.FLOAT,
		tail 											= ByteReader.Type.FLOAT,
		end 											= ByteReader.Type.FLOAT,
		unused3 										= ByteReader.Type.FLOAT,
		contact 										= ByteReader.Type.FLOAT,
		drop 											= ByteReader.Type.FLOAT,
		top 											= ByteReader.Type.FLOAT,
		unused6 										= ByteReader.Type.INT,
		unused7 										= ByteReader.Type.INT,
		unused8 										= ByteReader.Type.INT,
		szattachmentindex 								= ByteReader.Type.INT,
		unused 											= [ByteReader.Type.INT, 7],
	}

	var index: int;
	var type: int;
	var chain: int;
	var bone: int;
	var slot: int;
	var height: float;
	var radius: float;
	var floor: float;
	var pos: Vector3;
	var q: Quaternion;
	var compressedikerrorindex: int;
	var unused2: int;
	var i_start: int;
	var ikerrorindex: int;
	var start: float;
	var peak: float;
	var tail: float;
	var end: float;
	var unused3: float;
	var contact: float;
	var drop: float;
	var top: float;
	var unused6: int;
	var unused7: int;
	var unused8: int;
	var szattachmentindex: int;
	var unused: Array[int];

class MDLBodyPart:
	static var scheme:
		get: return {
		name_index 										= ByteReader.Type.INT,
		num_models 										= ByteReader.Type.INT,
		base 											= ByteReader.Type.INT,
		model_index 									= ByteReader.Type.INT,
	}

	var name: String;
	var name_index: int;
	var num_models: int;
	var base: int;
	var model_index: int;

	var address: int = 0;
	var models: Array = [];

	func _to_string():
		return "MDLBodyPart: {name: %s, name_index: %d, num_models: %d, base: %d, model_index: %d}" % [name, name_index, num_models, base, model_index];

class MDLModel:
	static var scheme:
		get: return {
		name 											= [ByteReader.Type.STRING, 64],
		type 											= ByteReader.Type.INT,
		bounding_radius 								= ByteReader.Type.FLOAT,
		num_meshes 										= ByteReader.Type.INT,
		mesh_offset 									= ByteReader.Type.INT,
		num_verts 										= ByteReader.Type.INT,
		vert_index 										= ByteReader.Type.INT,
		tangents_index 									= ByteReader.Type.INT,
		num_attachments 								= ByteReader.Type.INT,
		attachment_index 								= ByteReader.Type.INT,
		num_eyeballs 									= ByteReader.Type.INT,
		eyeball_index 									= ByteReader.Type.INT,
		unused 											= [ByteReader.Type.INT, 10],
	}

	var name: String;
	var type: int;
	var bounding_radius: float;
	var num_meshes: int;
	var mesh_offset: int;
	var num_verts: int;
	var vert_index: int;
	var tangents_index: int;
	var num_attachments: int;
	var attachment_index: int;
	var num_eyeballs: int;
	var eyeball_index: int;
	var unused: Array[int];
	var num_flexes: int;
	var flex_index: int;

	var address: int = 0;
	var meshes: Array = [];

	func _to_string():
		return "MDLModel: {name: %s, type: %d, bounding_radius: %f, num_meshes: %d, mesh_offset: %d, num_verts: %d, vert_index: %d, tangents_index: %d, num_attachments: %d, attachment_index: %d, num_eyeballs: %d, eyeball_index: %d, unused: %s}" % [name, type, bounding_radius, num_meshes, mesh_offset, num_verts, vert_index, tangents_index, num_attachments, attachment_index, num_eyeballs, eyeball_index, unused];

class MDLMesh:
	static var scheme:
		get: return {
		material 										= ByteReader.Type.INT,
		model_offset 									= ByteReader.Type.INT,
		vertex_count 									= ByteReader.Type.INT,
		vertex_index_start 								= ByteReader.Type.INT,
		flexes_count 									= ByteReader.Type.INT,
		flexes_offset 									= ByteReader.Type.INT,
		material_type 									= ByteReader.Type.INT,
		material_param 									= ByteReader.Type.INT,
		mesh_id 										= ByteReader.Type.INT,
		center 											= ByteReader.Type.VECTOR3,
		unused0 										= ByteReader.Type.INT,
		number_vertices_lod 							= [ByteReader.Type.INT, 8],
		vertex_offset_lod 								= [ByteReader.Type.INT, 8],
	}

	var material: int;
	var model_offset: int;
	var vertex_count: int;
	var vertex_index_start: int;
	var flexes_count: int;
	var flexes_offset: int;
	var material_type: int;
	var material_param: int;
	var mesh_id: int;
	var center: Vector3;
	var number_vertices_lod: Array[int];
	var vertex_offset_lod: Array[int];
	var unused0: int;

	var address: int = 0;

	func _to_string():
		return "MDLMesh: {material: %d, model_offset: %d, vertex_count: %d, vertex_index_start: %d, flexes_count: %d, flexes_offset: %d, material_type: %d, material_param: %d, mesh_id: %d, center: %s, number_vertices_lod: %s, vertex_offset_lod: %s}" % [material, model_offset, vertex_count, vertex_index_start, flexes_count, flexes_offset, material_type, material_param, mesh_id, center, number_vertices_lod, vertex_offset_lod];


var header: MDLHeader;
var textureDirs: Array = [];
var textures: Array = [];
var bones: Array = [];
var bone_controllers: Array = [];
var body_parts: Array = [];
var file: FileAccess;
var materials: Array = [];
var skin_families: Array = [];
var source_path: String = "";

var model_name:
	get: return source_path.get_file().split(".")[0];

func _init(source_path: String):
	file = FileAccess.open(source_path, FileAccess.READ);
	if file == null: return;

	self.source_path = source_path;

	header = ByteReader.read_by_structure(file, MDLHeader);

	_read_texture_data();
	_read_bones();
	_read_body_parts();
	_read_skin_families();

	file.close();

func _read_skin_families():
	file.seek(header.skin_offset);

	for i in range(header.skinfamily_count * header.skin_count):
		var j = i / header.skin_count;

		if skin_families.size() <= j:
			skin_families.append([]);

		skin_families[j].append(ByteReader._read_data(file, ByteReader.Type.SHORT));

func _read_body_parts():
	file.seek(header.bodypart_offset);

	body_parts = ByteReader.read_array(file, header, "bodypart_offset", "bodypart_count", MDLBodyPart);

	for bodypart in body_parts:
		bodypart.name = ByteReader.read_string(file, bodypart.address + bodypart.name_index);
		bodypart.models = ByteReader.read_array(file, bodypart, "model_index", "num_models", MDLModel);

		for model in bodypart.models:
			model.meshes = ByteReader.read_array(file, model, "mesh_offset", "num_meshes", MDLMesh);

func _read_texture_data():
	file.seek(header.texturedir_offset);
	for i in range(header.texturedir_count):
		textureDirs.append(ByteReader.read_string(file, file.get_32()));

	textures = ByteReader.read_array(file, header, "texture_offset", "texture_count", MDLTexture);
	for texture in textures:
		texture.name = ByteReader.read_string(file, texture.address + texture.name_offset);

func _read_bones():
	bones = ByteReader.read_array(file, header, "bone_offset", "bone_count", MDLBone);

	var bone_index = 0;
	for bone in bones:
		bone.name = ByteReader.read_string(file, bone.address + bone.name_offset);
		bone.surface_prop = ByteReader.read_string(file, bone.address + bone.surface_prop_index);
		bone.id = bone_index;
		bone_index += 1;

	bone_controllers = ByteReader.read_array(file, header, "bone_controller_offset", "bone_controller_count", MDLBoneController);
