class_name VTFTool

enum VTFFlags {
	# Flags from the *.txt config file
	TEXTUREFLAGS_POINTSAMPLE = 0x00000001,
	TEXTUREFLAGS_TRILINEAR = 0x00000002,
	TEXTUREFLAGS_CLAMPS = 0x00000004,
	TEXTUREFLAGS_CLAMPT = 0x00000008,
	TEXTUREFLAGS_ANISOTROPIC = 0x00000010,
	TEXTUREFLAGS_HINT_DXT5 = 0x00000020,
	TEXTUREFLAGS_PWL_CORRECTED = 0x00000040,
	TEXTUREFLAGS_NORMAL = 0x00000080,
	TEXTUREFLAGS_NOMIP = 0x00000100,
	TEXTUREFLAGS_NOLOD = 0x00000200,
	TEXTUREFLAGS_ALL_MIPS = 0x00000400,
	TEXTUREFLAGS_PROCEDURAL = 0x00000800,

	# These are automatically generated by vtex from the texture data.
	TEXTUREFLAGS_ONEBITALPHA = 0x00001000,
	TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000,

	# Newer flags from the *.txt config file
	TEXTUREFLAGS_ENVMAP = 0x00004000,
	TEXTUREFLAGS_RENDERTARGET = 0x00008000,
	TEXTUREFLAGS_DEPTHRENDERTARGET = 0x00010000,
	TEXTUREFLAGS_NODEBUGOVERRIDE = 0x00020000,
	TEXTUREFLAGS_SINGLECOPY	= 0x00040000,
	TEXTUREFLAGS_PRE_SRGB = 0x00080000,
		
  TEXTUREFLAGS_UNUSED_00100000 = 0x00100000,
	TEXTUREFLAGS_UNUSED_00200000 = 0x00200000,
	TEXTUREFLAGS_UNUSED_00400000 = 0x00400000,

	TEXTUREFLAGS_NODEPTHBUFFER = 0x00800000,

	TEXTUREFLAGS_UNUSED_01000000 = 0x01000000,

	TEXTUREFLAGS_CLAMPU = 0x02000000,
	TEXTUREFLAGS_VERTEXTEXTURE = 0x04000000,
	TEXTUREFLAGS_SSBUMP = 0x08000000,			

	TEXTUREFLAGS_UNUSED_10000000 = 0x10000000,

	TEXTUREFLAGS_BORDER = 0x20000000,

	TEXTUREFLAGS_UNUSED_40000000 = 0x40000000,
	TEXTUREFLAGS_UNUSED_80000000 = 0x80000000,
}

enum ImageFormat {
	IMAGE_FORMAT_RGBA8888,
	IMAGE_FORMAT_ABGR8888,
	IMAGE_FORMAT_RGB888,
	IMAGE_FORMAT_BGR888,
	IMAGE_FORMAT_RGB565,
	IMAGE_FORMAT_I8,
	IMAGE_FORMAT_IA88,
	IMAGE_FORMAT_P8,
	IMAGE_FORMAT_A8,
	IMAGE_FORMAT_RGB888_BLUESCREEN,
	IMAGE_FORMAT_BGR888_BLUESCREEN,
	IMAGE_FORMAT_ARGB8888,
	IMAGE_FORMAT_BGRA8888,
	IMAGE_FORMAT_DXT1,
	IMAGE_FORMAT_DXT3,
	IMAGE_FORMAT_DXT5,
	IMAGE_FORMAT_BGRX8888,
	IMAGE_FORMAT_BGR565,
	IMAGE_FORMAT_BGRX5551,
	IMAGE_FORMAT_BGRA4444,
	IMAGE_FORMAT_DXT1_ONEBITALPHA,
	IMAGE_FORMAT_BGRA5551,
	IMAGE_FORMAT_UV88,
	IMAGE_FORMAT_UVWQ8888,
	IMAGE_FORMAT_RGBA16161616F,
	IMAGE_FORMAT_RGBA16161616,
	IMAGE_FORMAT_UVLX8888,
	IMAGE_FORMAT_NONE = -1
}

class VMT:
	static var fileProps = [
		"basetexture",
		"basetexture2",
		"bumpmap",
		"bumpmap2",
		"detail",
		"detail2",
	];

	static var cache = {};

	var structure = {};
	var shader = "";

	static var config:
		get: 
			return VMFConfig.getConfig();

	static func create(materialPath):
		var path = "{0}/materials/{1}.vmt".format([config.gameInfoPath, materialPath]).replace('\\', '/').replace('//', '/').to_lower();

		var h = hash(materialPath);

		if not cache:
			cache = {};

		# if h in cache:
		# 	return cache[h];

		if not FileAccess.file_exists(path):
			VMFLogger.error("VMT file not found: {0}".format(path));
			return null;

		var instance = VMT.new(materialPath);
		cache[h] = instance;

		return instance;

	func get(key):
		var value = structure[key] if key in structure else null;

		if value == null:
			return null;

		if VMT.fileProps.has(key):
			return "{0}/materials/{1}.vtf".format([config.gameInfoPath, value]).replace('\\', '/').replace('//', '/').to_lower();

		return value;

	func _init(materialPath):
		var path = "{0}/materials/{1}.vmt".format([config.gameInfoPath, materialPath]).replace('\\', '/').replace('//', '/').to_lower();

		if not fileProps:
			VMT.fileProps = [
				"$basetexture",
				"$basetexture2",
				"$bumpmap",
				"$bumpmap2",
				"$detail",
				"$detail2",
			]
		
		structure = ValveFormatParser.parse(path);
		shader = structure.keys()[0];
		structure = structure[shader];

class VTF:
	static var cache = {};

	static var config:
		get: 
			return VMFConfig.getConfig().nodeConfig;

	func unsigned16_to_signed(unsigned):
		return (unsigned + (1 << 15)) % (1 << 16) - (1 << 15);

	var file = null;

	var signature:
		get:
			file.seek(0);
			return file.get_buffer(16).get_string_from_utf8();

	var version:
		get:
			file.seek(4);
			return float(".".join([file.get_32(), file.get_32()]));

	var headerSize:
		get:
			file.seek(12);
			return file.get_32();

	var width:
		get:
			file.seek(16);
			var width = file.get_16();

			if width == 0:
				print(file.get_path());

			return width if width > 0 else config.defaultTextureSize;

	var height:
		get:
			file.seek(18);

			var height = file.get_16();
			return height if height > 0 else config.defaultTextureSize;

	var flags:
		get:
			file.seek(20);
			return file.get_32();

	var frames:
		get:
			file.seek(24)
			return file.get_16();

	var firstFrame:
		get:
			file.seek(26);
			return file.get_16();

	var reflectivity:
		get:
			file.seek(32);
			return Vector3(file.get_float(), file.get_float(), file.get_float());

	var bumpScale:
		get:
			file.seek(48);
			return file.get_float();

	var hiresImageFormat:
		get:
			file.seek(52);
			return file.get_32();

	var mipmapCount:
		get:
			file.seek(56);
			return file.get_8();

	var lowResImageFormat:
		get:
			file.seek(57);
			return file.get_32();

	var lowResImageWidth:
		get:
			file.seek(61);
			return file.get_8();

	var lowResImageHeight:
		get:
			file.seek(62);
			return file.get_8();

	var depth:
		get:
			if version < 7.2:
				return 0;

			file.seek(63);
			return file.get_8();

	var numResources:
		get:
			if version < 7.3:
				return 0;

			file.seek(75);
			return file.get_32();

	var transform = {
		"scale": Vector2(1, 1),
	};

	static func create(fullPath):
		if not FileAccess.file_exists(fullPath):
			VMFLogger.error("File {0} is not exist".format([fullPath]));
			return null;

		if not cache:
			VMT.cache = {};

		var h = hash(fullPath);

		if h in cache:
			return cache[h];

		var instance = VTF.new(fullPath);
		cache[h] = instance;

		return instance;

	func _readMipMaps():
		var w = width / pow(2, mipmapCount - 1);
		var h = height / pow(2, mipmapCount - 1);
			
		file.seek(headerSize);

		for n in range(0, 2):
			var bytes = h * w * 8;

			print(file.get_buffer(bytes));

			w *= 2;
			h *= 2;
		pass;

	func _init(fullPath):
		file = FileAccess.open(fullPath, FileAccess.READ);

		_readMipMaps();


static func getTextureInfo(materialPath):
	var vmt = VMT.create(materialPath);
	var vtf = VTF.new(vmt.get("$basetexture"));

	return vtf;

static func importMaterial(materialPath):
	var vmt = VMT.create(materialPath);

	if not FileAccess.file_exists(vmt.get('$basetexture')):
		return;
